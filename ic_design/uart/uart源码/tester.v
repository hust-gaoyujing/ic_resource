//
// Module UART_V.tester.flow
//
// Created:
//          by - user.group (host.domain)
//          at - 10:56:04 30 Aug 2001
//
// Generated by Mentor Graphics' HDL Designer(TM) 2001.5
//

`resetall
`timescale 1ns/10ps
module tester( 
   data_out, 
   int, 
   sout, 
   addr, 
   clk, 
   cs, 
   data_in, 
   nrw, 
   rst, 
   sin
);


// Internal Declarations

input  [7:0] data_out;
input        int;
input        sout;
output [2:0] addr;
output       clk;
output       cs;
output [7:0] data_in;
output       nrw;
output       rst;
output       sin;


wire [7:0] data_out;
wire int;
wire sout;
reg [2:0] addr;
reg clk;
reg cs;
reg [7:0] data_in;
reg nrw;
reg rst;
reg sin;
// pragma synthesis_off
reg tester_top_hds_animation_indicator;
// pragma synthesis_on

// Module declarations
parameter clk_prd = 100 ;
parameter rcv_clk_prd = (clk_prd * 6);

reg [7:0] div_lsb, div_msb, ser_data, xmit_data;
reg int_clk;

reg [7:0] read_data;
integer i;
// ---------------------
//    UART_WRITE
// ---------------------
task uart_write;
   input [7:0] bit_data;
   input [2:0] address;
begin
   addr = address;
   nrw = # (clk_prd) 1;
   data_in = bit_data;
   cs = #(clk_prd) 0;
   cs = #(5*clk_prd) 1;
   nrw = #(clk_prd) 0;
   # clk_prd;
end
endtask

// ---------------------
//    UART_READ
// ---------------------
task uart_read ;
input [2:0] address;
begin
    addr = address;
    nrw = #( 2*clk_prd) 0 ;
    cs = #(clk_prd) 0;
    #(9*clk_prd);
    read_data = data_out;
    cs = #(2*clk_prd) 1 ; 
    #clk_prd;
 end
endtask

///////////////////////////////////////////////////////////////////////////
// Flowchart tester_top
initial 
begin : tester_top
   // pragma synthesis_off
   $hdsCurrentPath(0,1);
   // pragma synthesis_on
   // pragma synthesis_off
   $hdsCurrentPath(0,2);
   // pragma synthesis_on
   int_clk = 0;
   div_lsb = 8'b00000110;
   div_msb = 8'b0;
   ser_data = 8'b11001110;
   xmit_data = 8'b01011010;
   cs = 1;
   nrw = 0;
   addr = "000";
   sin = 1;
   rst = 0;
   data_in = # clk_prd 8'b00000000;
   rst = # (clk_prd) 1 ;
   // pragma synthesis_off
   $hdsCurrentPath(0,3);
   // pragma synthesis_on
   # (3*clk_prd);
   // pragma synthesis_off
   $hdsCurrentPath(0,4);
   // pragma synthesis_on
   uart_write(div_lsb,0);
   // pragma synthesis_off
   $hdsCurrentPath(0,5);
   // pragma synthesis_on
   # (7*clk_prd);
   // pragma synthesis_off
   $hdsCurrentPath(0,6);
   // pragma synthesis_on
   uart_write(div_msb,1);
   // pragma synthesis_off
   $hdsCurrentPath(0,7);
   // pragma synthesis_on
   # (7*clk_prd);
   // pragma synthesis_off
   $hdsCurrentPath(0,8);
   // pragma synthesis_on

   // pragma synthesis_off
   $hdsCurrentPath(0,9);
   // pragma synthesis_on
   uart_write(xmit_data,4);
   // pragma synthesis_off
   $hdsCurrentPath(0,10);
   // pragma synthesis_on
   for (i=0;i<60;i=i+1) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,11);
      // pragma synthesis_on
      if (int==1) begin
         // pragma synthesis_off
         $hdsCurrentPath(0,12);
         // pragma synthesis_on
         i = 60;
      end
      else begin
         // pragma synthesis_off
         $hdsCurrentPath(0,13);
         // pragma synthesis_on
         #clk_prd;
      end
   // pragma synthesis_off
   $hdsCurrentPath(0,14);
   // pragma synthesis_on
   end
   // pragma synthesis_off
   $hdsCurrentPath(0,15);
   // pragma synthesis_on
   if (int==1 && i != 60) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,16);
      // pragma synthesis_on
      wait (int_clk == 0 || int_clk);
      // pragma synthesis_off
      $hdsCurrentPath(0,17);
      // pragma synthesis_on
      uart_read(7);
   end
   else begin
      // pragma synthesis_off
      $hdsCurrentPath(0,18);
      // pragma synthesis_on
      wait (int_clk == 0 || int_clk);
      // pragma synthesis_off
      $hdsCurrentPath(0,19);
      // pragma synthesis_on
      $display("Test bench failure : interrupt did not occur");
   end

   // pragma synthesis_off
   $hdsCurrentPath(0,20);
   // pragma synthesis_on

   // pragma synthesis_off
   $hdsCurrentPath(0,21);
   // pragma synthesis_on
   sin = 0;
   // pragma synthesis_off
   $hdsCurrentPath(0,22);
   // pragma synthesis_on
   # (3*clk_prd);
   // pragma synthesis_off
   $hdsCurrentPath(0,23);
   // pragma synthesis_on
   for (i=0;i<8;i=i+1) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,24);
      // pragma synthesis_on
      sin <= ser_data[i];
      // pragma synthesis_off
      $hdsCurrentPath(0,25);
      // pragma synthesis_on
      # (6*clk_prd);
   // pragma synthesis_off
   $hdsCurrentPath(0,26);
   // pragma synthesis_on
   end
   // pragma synthesis_off
   $hdsCurrentPath(0,27);
   // pragma synthesis_on
   sin = 1;
   // pragma synthesis_off
   $hdsCurrentPath(0,28);
   // pragma synthesis_on
   # (10*clk_prd);
   // pragma synthesis_off
   $hdsCurrentPath(0,29);
   // pragma synthesis_on
   uart_read(7);
   // pragma synthesis_off
   $hdsCurrentPath(0,30);
   // pragma synthesis_on
   uart_read(5);
   // pragma synthesis_off
   $hdsCurrentPath(0,31);
   // pragma synthesis_on
   if (!(read_data == ser_data)) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,32);
      // pragma synthesis_on
      $display( "Test bench failure : Read Data did NOT equal Serial Data");
   end

   // pragma synthesis_off
   $hdsCurrentPath(0,33);
   // pragma synthesis_on

   // pragma synthesis_off
   $hdsCurrentPath(0,34);
   // pragma synthesis_on
   uart_read(6);
   // pragma synthesis_off
   $hdsCurrentPath(0,35);
   // pragma synthesis_on
   if (!(read_data == 8'b0)) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,36);
      // pragma synthesis_on
      $display("Status NOT zero");
   end

   // pragma synthesis_off
   $hdsCurrentPath(0,37);
   // pragma synthesis_on
   $display("Uart Testing Complete");
   $stop;
   // pragma synthesis_off
   $hdsCurrentPath(0,38);
   // pragma synthesis_on
end

// Concurrent statements
// Clock Generator
initial
   begin
   int_clk = 0;
   forever #(clk_prd/2) int_clk = ~int_clk;
   end

always @(int_clk)
   clk = int_clk;

endmodule // tester

