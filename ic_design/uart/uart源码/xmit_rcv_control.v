//
// Module UART_V.xmit_rcv_control.fsm
//
// Created:
//          by - user.group (host.domain)
//          at - 10:56:05 30 Aug 2001
//
// Generated by Mentor Graphics' HDL Designer(TM) 2001.5
//

`resetall
`timescale 1ns/10ps
module xmit_rcv_control( 
   clk, 
   rst, 
   sample, 
   sin, 
   start_xmit, 
   xmitdt, 
   done_rcving, 
   done_xmitting, 
   enable_rcv_clk, 
   enable_xmit_clk, 
   rcv_bit_cnt, 
   rcving, 
   read_bit, 
   sout, 
   xmitting
);


// Internal Declarations

input        clk;
input        rst;
input        sample;
input        sin;
input        start_xmit;
input  [7:0] xmitdt;
output       done_rcving;
output       done_xmitting;
output       enable_rcv_clk;
output       enable_xmit_clk;
output [2:0] rcv_bit_cnt;
output       rcving;
output       read_bit;
output       sout;
output       xmitting;


wire clk;
wire rst;
wire sample;
wire sin;
wire start_xmit;
wire [7:0] xmitdt;
reg done_rcving;
reg done_xmitting;
reg enable_rcv_clk;
reg enable_xmit_clk;
reg [2:0] rcv_bit_cnt;
reg rcving;
reg read_bit;
reg sout;
reg xmitting;
// Declare any pre-registered internal signals
reg enable_xmit_clk_cld ;
reg [2:0] rcv_bit_cnt_cld ;
reg sout_cld ;
reg xmitting_cld ;

// Module Declarations
reg  [2:0] xmit_bit_cnt ;

// State encoding
parameter [2:0] // pragma enum Rcv_current_state_code
   waiting = 3'd0 ,
   check_lock = 3'd1 ,
   rcv_locked = 3'd2 ,
   read_data = 3'd3 ,
   incr_count2 = 3'd4 ,
   done_read = 3'd5 ,
   read_stop_bit = 3'd6 ,
   finish_rcv = 3'd7 ;
// State encoding
parameter [2:0] // pragma enum Xmit_current_state_code
   waiting_to_xmit = 3'd0 ,
   send_start = 3'd1 ,
   send_data = 3'd2 ,
   incr_count = 3'd3 ,
   done_xmit = 3'd4 ,
   send_stop_bit = 3'd5 ,
   finish_xmit = 3'd6 ;

reg [2:0] /* pragma enum Rcv_current_state_code */ Rcv_current_state, Rcv_next_state ;
// pragma synthesis_off
reg Rcv_hds_animation_indicator;
// pragma synthesis_on
reg [2:0] /* pragma enum Xmit_current_state_code */ Xmit_current_state, Xmit_next_state ;

//----------------------------------------------------------------------------
// Next State Block for machine Rcv
//----------------------------------------------------------------------------
always  @(
   Rcv_current_state or 
   rcv_bit_cnt_cld or 
   sample or 
   sin) 
begin
   case (Rcv_current_state)
      waiting:
         if (~sin)
         begin
            Rcv_next_state <= check_lock;
            // pragma synthesis_off
            $hdsNextPath(0,1);
            // pragma synthesis_on
         end
         else
         begin
            Rcv_next_state <= waiting;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      check_lock:
         if (sin)
         begin
            Rcv_next_state <= waiting;
            // pragma synthesis_off
            $hdsNextPath(0,2);
            // pragma synthesis_on
         end
         else if (~sin)
         begin
            Rcv_next_state <= rcv_locked;
            // pragma synthesis_off
            $hdsNextPath(0,3);
            // pragma synthesis_on
         end
         else
         begin
            Rcv_next_state <= check_lock;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      rcv_locked:
         if (sample)
         begin
            Rcv_next_state <= read_data;
            // pragma synthesis_off
            $hdsNextPath(0,4);
            // pragma synthesis_on
         end
         else
         begin
            Rcv_next_state <= rcv_locked;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      read_data:
         if (~sample)
         begin
            Rcv_next_state <= incr_count2;
            // pragma synthesis_off
            $hdsNextPath(0,5);
            // pragma synthesis_on
         end
         else
         begin
            Rcv_next_state <= read_data;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      incr_count2:
         if (sample && rcv_bit_cnt_cld !== 7)
         begin
            Rcv_next_state <= read_data;
            // pragma synthesis_off
            $hdsNextPath(0,6);
            // pragma synthesis_on
         end
         else if (sample && rcv_bit_cnt_cld == 7)
         begin
            Rcv_next_state <= done_read;
            // pragma synthesis_off
            $hdsNextPath(0,7);
            // pragma synthesis_on
         end
         else
         begin
            Rcv_next_state <= incr_count2;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      done_read:
         if (~sample)
         begin
            Rcv_next_state <= read_stop_bit;
            // pragma synthesis_off
            $hdsNextPath(0,8);
            // pragma synthesis_on
         end
         else
         begin
            Rcv_next_state <= done_read;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      read_stop_bit:
         if (sample)
         begin
            Rcv_next_state <= finish_rcv;
            // pragma synthesis_off
            $hdsNextPath(0,9);
            // pragma synthesis_on
         end
         else
         begin
            Rcv_next_state <= read_stop_bit;
            // pragma synthesis_off
            $hdsNextPath(0,0);
            // pragma synthesis_on
         end
      finish_rcv:
         begin
            Rcv_next_state <= waiting;

            // pragma synthesis_off
            $hdsNextPath(0,10);
            // pragma synthesis_on
         end
      default: begin
         Rcv_next_state <= waiting;
         // pragma synthesis_off
         $hdsNextPath(0,0);
         // pragma synthesis_on
      end
   endcase

end // Next State Block

//----------------------------------------------------------------------------
// Next State Block for machine Xmit
//----------------------------------------------------------------------------
always  @(
   Xmit_current_state or 
   sample or 
   start_xmit or 
   xmit_bit_cnt) 
begin
   case (Xmit_current_state)
      waiting_to_xmit:
         if (start_xmit)
            Xmit_next_state <= send_start;
         else
            Xmit_next_state <= waiting_to_xmit;
      send_start:
         if (sample)
            Xmit_next_state <= send_data;
         else
            Xmit_next_state <= send_start;
      send_data:
         if (~sample)
            Xmit_next_state <= incr_count;
         else
            Xmit_next_state <= send_data;
      incr_count:
         if (sample && xmit_bit_cnt !== 0)
            Xmit_next_state <= send_data;
         else if (sample && ~xmit_bit_cnt)
            Xmit_next_state <= done_xmit;
         else
            Xmit_next_state <= incr_count;
      done_xmit:
         if (~sample)
            Xmit_next_state <= send_stop_bit;
         else
            Xmit_next_state <= done_xmit;
      send_stop_bit:
            Xmit_next_state <= finish_xmit;

      finish_xmit:
            Xmit_next_state <= waiting_to_xmit;

      default: begin
         Xmit_next_state <= waiting_to_xmit;
      end
   endcase

end // Next State Block

//----------------------------------------------------------------------------
// Output Block for machine Rcv
//----------------------------------------------------------------------------
always  @(
   Rcv_current_state or 
   rcv_bit_cnt_cld or 
   sample or 
   sin) 
begin
   // Default Assignment
   done_rcving <= 0;
   enable_rcv_clk <= 0;
   rcving <= 0;
   read_bit <= 0;
   // Default Assignment To Internals

   // Combined Actions
   case (Rcv_current_state)
      waiting: begin
         if (~sin) begin
            enable_rcv_clk <= 1;
         end
      end
      check_lock: begin
         enable_rcv_clk <= 1;
         if (sin) begin
            enable_rcv_clk <= 0;
         end
      end
      rcv_locked: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
      end
      read_data: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
      end
      incr_count2: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
         if (sample && rcv_bit_cnt_cld !== 7) begin
            read_bit <= 1;
         end
         else if (sample && rcv_bit_cnt_cld == 7) begin
            read_bit <= 1;
         end
      end
      done_read: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
      end
      read_stop_bit: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
      end
      finish_rcv: begin
         enable_rcv_clk <= 0;
         rcving <= 0;
         done_rcving <= 1;
      end
   endcase

end // Output Block

//----------------------------------------------------------------------------
// Output Block for machine Xmit
//----------------------------------------------------------------------------
always  @(
   Xmit_current_state) 
begin
   // Default Assignment
   done_xmitting <= 0;
   // Default Assignment To Internals

   // Combined Actions
   case (Xmit_current_state)
      send_stop_bit: begin
         done_xmitting <= 1;
      end
   endcase

end // Output Block

//----------------------------------------------------------------------------
// Clocked Block for machine Rcv
//----------------------------------------------------------------------------
always @(
   posedge clk or negedge rst
) begin
   if (!rst) begin
      Rcv_current_state <= waiting;
      // Reset Values
      rcv_bit_cnt_cld <= 0;
   end
   else begin
      Rcv_current_state <= Rcv_next_state;
      // pragma synthesis_off
      $hdsClock(0);
      // pragma synthesis_on
      // Default Assignment To Internals
      // Combined Actions for internal signals only
      case (Rcv_current_state)
         waiting: begin
            rcv_bit_cnt_cld <= 0;
            if (~sin) begin
               rcv_bit_cnt_cld <= 0;
            end
         end
         incr_count2: begin
            if (sample && rcv_bit_cnt_cld !== 7) begin
               rcv_bit_cnt_cld <= rcv_bit_cnt_cld + 1;
            end
         end
      endcase

   end
end // Clocked Block

//----------------------------------------------------------------------------
// Clocked Block for machine Xmit
//----------------------------------------------------------------------------
always @(
   posedge clk or negedge rst
) begin
   if (!rst) begin
      Xmit_current_state <= waiting_to_xmit;
      // Reset Values
      enable_xmit_clk_cld <= 0;
      sout_cld <= 1;
      xmitting_cld <= 0;
      xmit_bit_cnt <= 0;
   end
   else begin
      Xmit_current_state <= Xmit_next_state;
      // Default Assignment To Internals
      sout_cld <= 1;
      // Combined Actions for internal signals only
      case (Xmit_current_state)
         waiting_to_xmit: begin
            xmit_bit_cnt <= 0;
         end
         send_start: begin
            sout_cld <= 0;
            enable_xmit_clk_cld <= 1;
            xmitting_cld <= 1;
         end
         send_data: begin
            sout_cld <= xmitdt[xmit_bit_cnt];
            if (~sample) begin
               xmit_bit_cnt <= xmit_bit_cnt + 1;
            end
         end
         incr_count: begin
            sout_cld <= xmitdt[xmit_bit_cnt];
         end
         finish_xmit: begin
            enable_xmit_clk_cld <= 0;
            xmitting_cld <= 0;
         end
      endcase

   end
end // Clocked Block

// Concurrent Statements
// Clocked output assignments
always @(
   enable_xmit_clk_cld or 
   rcv_bit_cnt_cld or 
   sout_cld or 
   xmitting_cld
)
begin
   enable_xmit_clk <= enable_xmit_clk_cld;
   rcv_bit_cnt <= rcv_bit_cnt_cld;
   sout <= sout_cld;
   xmitting <= xmitting_cld;
end

endmodule // xmit_rcv_control

