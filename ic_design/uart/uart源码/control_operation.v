//
// Module UART_V.control_operation.fsm
//
// Created:
//          by - user.group (host.domain)
//          at - 10:56:04 30 Aug 2001
//
// Generated by Mentor Graphics' HDL Designer(TM) 2001.5
//

`resetall
`timescale 1ns/10ps
module control_operation( 
   clk, 
   clr_int_en, 
   cs, 
   nrw, 
   rst, 
   xmitdt_en, 
   clear_flags, 
   enable_write, 
   start_xmit
);


// Internal Declarations

input   clk;
input   clr_int_en;
input   cs;
input   nrw;
input   rst;
input   xmitdt_en;
output  clear_flags;
output  enable_write;
output  start_xmit;


wire clk;
wire clr_int_en;
wire cs;
wire nrw;
wire rst;
wire xmitdt_en;
reg clear_flags;
reg enable_write;
reg start_xmit;
// Module Declarations
// State encoding
parameter [2:0] // pragma enum current_state_code
   waiting = 3'd0 ,
   reading_from_reg = 3'd1 ,
   clearing_flags = 3'd2 ,
   writing_to_reg = 3'd3 ,
   xmitting = 3'd4 ;

reg [2:0] /* pragma enum current_state_code */ current_state, next_state ;
// pragma state_vector current_state

//----------------------------------------------------------------------------
// Next State Block for machine cntrl_op
//----------------------------------------------------------------------------
always  @(
   clr_int_en or 
   cs or 
   current_state or 
   nrw or 
   xmitdt_en) 
begin
   // Default Assignment
   clear_flags = 0;
   enable_write = 0;
   start_xmit = 0;
   // Default Assignment To Internals

   // Combined Actions
   case (current_state)
      waiting:
      begin
         if (nrw  && ~cs)
            next_state = writing_to_reg;
         else if (~nrw && ~cs)
            next_state = reading_from_reg;
         else
            next_state = waiting;
      end
      reading_from_reg:
      begin
         if (cs)
            next_state = waiting;
         else if (~nrw && clr_int_en)
            next_state = clearing_flags;
         else
            next_state = reading_from_reg;
      end
      clearing_flags:
      begin
         clear_flags = 1;
         if (cs)
            next_state = waiting;
         else
            next_state = clearing_flags;
      end
      writing_to_reg:
      begin
         enable_write = 1;
         if (cs)
            next_state = waiting;
         else if (nrw && xmitdt_en)
            next_state = xmitting;
         else
            next_state = writing_to_reg;
      end
      xmitting:
      begin
         start_xmit = 1;
         if (cs)
            next_state = waiting;
         else
            next_state = xmitting;
      end
      default: begin
         next_state = waiting;
      end
   endcase

end // Next State Block

//----------------------------------------------------------------------------
// Clocked Block for machine cntrl_op
//----------------------------------------------------------------------------
always @(
   posedge clk or negedge rst
) begin
   if (!rst) begin
      current_state <= waiting;
      // Reset Values
   end
   else begin
      current_state <= next_state;
      // Default Assignment To Internals
   end
end // Clocked Block

// Concurrent Statements
endmodule // control_operation

